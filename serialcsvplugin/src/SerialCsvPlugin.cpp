// Copyright DEWETRON GmbH 2020


#include <memory>

#include "odkfw_properties.h"
#include "odkfw_custom_request_handler.h"
#include "odkfw_software_channel_plugin.h"
#include "serialcsvplugin/CsvDecoder.h"
#include "serial/serial.h"
#include "qml.rcc.h"
#include <boost/lexical_cast.hpp>

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char *PLUGIN_MANIFEST =
    R"XML(<?xml version="1.0"?>                        
<OxygenPlugin name="SERIAL_CSV_PLUGIN" version="1.0" uuid="674c23a5-590a-4c7f-8aac-a97ed94a0ea5">
  <Info name="Serial Plugin: Simple ASCII Interpreter to Oxygen-Channels.">
    <Vendor name="staySmart"/>
    <Description>
    A simple plugin to further process data from a microcontroller send over serial. 
    Implements a simple, ASCII/CSV based protocol.
    </Description>
  </Info>
  <Host minimum_version="5.3"/>
  <UsesUIExtensions/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char *TRANSLATION_EN =
R"XML(<?xml version="1.0"?>

<!-- English -->
<TS version="2.1" language="en" sourcelanguage="en">

    <!-- Translations for Config-Keys -->
    <context><name>ConfigKeys</name>
        <message><source>SERIAL_CSV_PLUGIN/ComPort</source><translation>COM Port</translation></message>
        <message><source>SERIAL_CSV_PLUGIN/BaudRate</source><translation>Baud rate</translation></message>
    </context>



    <!-- Translations for custom UI item -->
    <context><name>SERIAL_CSV_PLUGIN/AddSerialCsvPort</name>
        <message><source>Not a valid CSV file</source><translation>No valid CSV file selected</translation></message>
    </context>
</TS>
)XML";


static const char* SERIAL_COM_PORT = "SERIAL_CSV_PLUGIN/ComPort";
static const char* SERIAL_BAUDRATE = "SERIAL_CSV_PLUGIN/BaudRate";

// Keys for ConfigItems that are used to store channel settings
// Custom key (prefixed by plugin name) to store path to the input file
// Value of common Oxygen key "SampleRate" determines the sample frequency and the playback rate for the channel

using namespace odk::framework;

class SerialCsvChannel : public SoftwareChannelInstance
{
public:
    SerialCsvChannel()
        : m_com_port_prop(new EditableStringProperty("COM-Port"))
        , m_baudrate_prop(new EditableStringProperty("Baudrate"))
        , m_num_channels()
        , m_csv_decoder()
    {
    }

    ~SerialCsvChannel()
    {
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Serial Plugin: Simply add serial data to oxygen.";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Data Sources";
        telegram.m_description = "Adds a serial port with a variable amount of channels to Oxygen. Default interpreter: CSV-Like format.";
        
        // Testing qml
        telegram.m_ui_item_add = "qml/AddSerialCsvPort";
        return telegram;
    }

    bool setup(const std::vector<odk::Property>& properties) override
    {
        odk::PropertyList props(properties);

        auto serialport = props.getString("SERIAL_CSV_PLUGIN/SerialPort");
        auto baudrate = props.getString("SERIAL_CSV_PLUGIN/BaudRate");
        auto numchannels = props.getString("SERIAL_CSV_PLUGIN/NumChannels");
        try
        {
            m_num_channels = boost::lexical_cast<uint32_t>(numchannels);
            m_baudrate_prop->setValue(baudrate);

        }
        catch(const boost::bad_lexical_cast&)
        { }

        if (!serialport.empty() && !baudrate.empty())
        {
            m_com_port_prop->setValue(serialport);
            createChannels();
        }

        return true;
    }

    bool createChannels()
    {
        for (uint32_t channel_no = 0; channel_no < m_num_channels; ++channel_no)
        {
            std::string name = std::string("S ") + std::to_string(channel_no + 1);
            auto channel = addOutputChannel(name);
            if (channel)
            {
                channel->setDefaultName(name)
                    .setSampleFormat(
                        odk::ChannelDataformat::SampleOccurrence::ASYNC,
                        odk::ChannelDataformat::SampleFormat::DOUBLE,
                        1)
                    .setRange({ -10, 10, "V", "V"})
                    ;
            }
        }

        return true;
    }

    bool update() override
    {
        return true;
    }

    void updatePropertyTypes(const PluginChannelPtr &output_channel) override
    {
        ODK_UNUSED(output_channel);
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr &channel) override
    {
        ODK_UNUSED(channel);
    }

    void create(odk::IfHost* host) override
    {
        ODK_UNUSED(host);

        getRootChannel()->setDefaultName(std::string("Serial-CSV ") + m_com_port_prop->getValue())
            .setDeletable(true)
            .addProperty(SERIAL_COM_PORT, m_com_port_prop)
            .addProperty(SERIAL_BAUDRATE, m_baudrate_prop);
    }

    bool configure(
        const odk::UpdateChannelsTelegram &request,
        std::map<std::uint32_t, std::uint32_t> &channel_id_map) override
    {
        configureFromTelegram(request, channel_id_map);
        return true;
    }

    void prepareProcessing(odk::IfHost *host) override
    {
        ODK_UNUSED(host);
        uint32_t baudrate = 9600;
        try
        {
            baudrate = boost::lexical_cast<uint32_t>(m_baudrate_prop->getValue());
        }
        catch(const boost::bad_lexical_cast&) {}

        m_csv_decoder.setTimeSource([host](void) { return getMasterTimestamp(host).m_ticks; });
        m_csv_decoder.listenOnComPort({ m_com_port_prop->getValue(), baudrate });
    }

    void stopProcessing(odk::IfHost* host) override
    { 
        ODK_UNUSED(host);
        m_csv_decoder.stopListening();
        m_csv_decoder.clear();
        m_csv_decoder.setTimeSource({});
    }

    void process(ProcessingContext &context, odk::IfHost *host) override
    {
        ODK_UNUSED(context);
        ODK_UNUSED(host);

        // CSV source channels
        auto& csv_channels = m_csv_decoder.getChannels();

        // Oxygen channels
        const auto& channels = getOutputChannels();
        auto ts = getMasterTimestamp(host);

        int chidx = 0;
        for (auto ch : channels)
        {
            // skip parent group channel
            if (!ch->getLocalParent()) continue;

            // check out of range access
            if (chidx >= csv_channels.size()) return;

            auto& csv_chan = csv_channels.at(chidx);
               
            auto data_set = csv_chan->getAndResetDataset();

            for (const auto& sample : data_set)
            {
                addSample(host, ch->getLocalId(), sample.time, sample.value);
            }
            ++chidx;
        }
    }

private:
    std::shared_ptr<EditableStringProperty> m_com_port_prop;
    std::shared_ptr<EditableStringProperty> m_baudrate_prop;
    uint32_t m_num_channels;
    serialcsv::CsvDecoder m_csv_decoder;
};

class SerialCsvChannelPlugin : public SoftwareChannelPlugin<SerialCsvChannel>
{
public:
    SerialCsvChannelPlugin()
        : m_custom_requests(std::make_shared<odk::framework::CustomRequestHandler>())
    {
        addMessageHandler(m_custom_requests);

        namespace arg = std::placeholders;
        m_custom_requests->registerFunction(1, "queryComPorts", std::bind(&SerialCsvChannelPlugin::queryComPorts, this, arg::_1, arg::_2));
        m_custom_requests->registerFunction(2, "selectComPort", std::bind(&SerialCsvChannelPlugin::selectComPort, this, arg::_1, arg::_2));
    }

    void registerResources() final
    {
        addTranslation(TRANSLATION_EN);
        addQtResources(plugin_resources::QML_RCC_data, plugin_resources::QML_RCC_size);
    }

    std::uint64_t queryComPorts(const odk::PropertyList &params, odk::PropertyList &returns)
    {
        ODK_UNUSED(params);

        auto ser_port_list = serial::list_ports();

        // sort by name
        std::sort(ser_port_list.begin(), ser_port_list.end(), [](const serial::PortInfo& l, const serial::PortInfo& r) {
            return l.port < r.port;
            }
        );

        for (const auto& sp : ser_port_list)
        {
            returns.setString("", sp.port);
            returns.setString("", sp.description);
        }

        return odk::error_codes::OK;
    }

    std::uint64_t selectComPort(const odk::PropertyList& params, odk::PropertyList& returns)
    {
        ODK_UNUSED(params);

        const auto serialport = params.getString("serialport");
        const auto baudrate = params.getString("baudrate");

        if (!serialport.empty())
        {
            // TODO scanning for incoming traffic

        }

        returns.setSigned("status", 0);

        return odk::error_codes::OK;
    }

private:
    std::shared_ptr<odk::framework::CustomRequestHandler> m_custom_requests;
};

OXY_REGISTER_PLUGIN1("SERIAL_CSV_PLUGIN", PLUGIN_MANIFEST, SerialCsvChannelPlugin);
