// Copyright DEWETRON GmbH 2020


#include <memory>

#include "odkfw_properties.h"
#include "odkfw_custom_request_handler.h"
#include "odkfw_software_channel_plugin.h"
#include "serial/serial.h"
#include "qml.rcc.h"

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char *PLUGIN_MANIFEST =
    R"XML(<?xml version="1.0"?>                        
<OxygenPlugin name="SERIAL_CSV_PLUGIN" version="1.0" uuid="674c23a5-590a-4c7f-8aac-a97ed94a0ea5">
  <Info name="Serial Plugin: Simple ASCII Interpreter to Oxygen-Channels.">
    <Vendor name="staySmart"/>
    <Description>
    A simple plugin to further process data from a microcontroller send over serial. 
    Implements a simple, ASCII/CSV based protocol.
    </Description>
  </Info>
  <Host minimum_version="5.3"/>
  <UsesUIExtensions/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char *TRANSLATION_EN =
R"XML(<?xml version="1.0"?>

<!-- English -->
<TS version="2.1" language="en" sourcelanguage="en">

    <!-- Translations for Config-Keys -->
    <context><name>ConfigKeys</name>
        <message><source>SERIAL_CSV_PLUGIN/ComPort</source><translation>COM Port</translation></message>
    </context>



    <!-- Translations for custom UI item -->
    <context><name>SERIAL_CSV_PLUGIN/AddSerialCsvPort</name>
        <message><source>Not a valid CSV file</source><translation>No valid CSV file selected</translation></message>
    </context>
</TS>
)XML";


static const char* SERIAL_COM_PORT = "SERIAL_CSV_PLUGIN/ComPort";

// Keys for ConfigItems that are used to store channel settings
// Custom key (prefixed by plugin name) to store path to the input file
// Value of common Oxygen key "SampleRate" determines the sample frequency and the playback rate for the channel

using namespace odk::framework;

class SerialCsvChannel : public SoftwareChannelInstance
{
public:
    SerialCsvChannel()
    : m_com_port(new EditableStringProperty("COM-Port"))
    {
        // Testing list-property
        //m_com_port->addOption("COM1");
        //m_com_port->addOption("COM2");
        auto ser_port_list = serial::list_ports();
        for (const auto& sp : ser_port_list)
        {
            m_com_port->addOption(sp.port);
        }
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Serial Plugin: Simply add serial data to oxygen.";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Data Sources";
        telegram.m_description = "Adds a serial port with a variable amount of channels to Oxygen. Default interpreter: CSV-Like format.";
        
        // Testing qml
        telegram.m_ui_item_add = "qml/AddSerialCsvPort";
        return telegram;
    }

    bool setup(const std::vector<odk::Property>& properties) override
    {
        odk::PropertyList props(properties);
        return true;
    }

    bool update() override
    {
        return true;
    }

    void updatePropertyTypes(const PluginChannelPtr &output_channel) override
    {
        ODK_UNUSED(output_channel);
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr &channel) override
    {
        ODK_UNUSED(channel);
    }

    void create(odk::IfHost* host) override
    {
        ODK_UNUSED(host);

        getRootChannel()->setDefaultName("Serial-CSV")
            .setSampleFormat(
                odk::ChannelDataformat::SampleOccurrence::ASYNC,
                odk::ChannelDataformat::SampleFormat::DOUBLE,
                1)
            .setDeletable(true)
            .addProperty(SERIAL_COM_PORT, m_com_port);
    }

    bool configure(
        const odk::UpdateChannelsTelegram &request,
        std::map<std::uint32_t, std::uint32_t> &channel_id_map) override
    {
        configureFromTelegram(request, channel_id_map);
        return true;
    }

    void prepareProcessing(odk::IfHost *host) override
    {
        ODK_UNUSED(host);
    }

    void process(ProcessingContext &context, odk::IfHost *host) override
    {
        ODK_UNUSED(context);
        ODK_UNUSED(host);
    }

private:
std::shared_ptr<EditableStringProperty> m_com_port;
};

class SerialCsvChannelPlugin : public SoftwareChannelPlugin<SerialCsvChannel>
{
public:
    SerialCsvChannelPlugin()
        : m_custom_requests(std::make_shared<odk::framework::CustomRequestHandler>())
    {
        addMessageHandler(m_custom_requests);

        namespace arg = std::placeholders;
        m_custom_requests->registerFunction(1, "queryComPorts", std::bind(&SerialCsvChannelPlugin::queryComPorts, this, arg::_1, arg::_2));
    }

    void registerResources() final
    {
        addTranslation(TRANSLATION_EN);
        addQtResources(plugin_resources::QML_RCC_data, plugin_resources::QML_RCC_size);
    }

    std::uint64_t queryComPorts(const odk::PropertyList &params, odk::PropertyList &returns)
    {
        ODK_UNUSED(params);

        auto ser_port_list = serial::list_ports();

        // sort by name
        std::sort(ser_port_list.begin(), ser_port_list.end(), [](const serial::PortInfo& l, const serial::PortInfo& r) {
            return l.port < r.port;
            }
        );

        for (const auto& sp : ser_port_list)
        {
            returns.setString("", sp.port);
            returns.setString("", sp.description);
        }

        return odk::error_codes::OK;
    }

private:
    std::shared_ptr<odk::framework::CustomRequestHandler> m_custom_requests;
};

OXY_REGISTER_PLUGIN1("SERIAL_CSV_PLUGIN", PLUGIN_MANIFEST, SerialCsvChannelPlugin);
