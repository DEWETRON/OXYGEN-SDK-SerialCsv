// Copyright DEWETRON GmbH 2020

#include <memory>

#include "odkfw_properties.h"
#include "odkfw_custom_request_handler.h"
#include "odkfw_software_channel_plugin.h"
#include "serialcsvplugin/CsvDecoder.h"
#include "serial/serial.h"
#include "qml.rcc.h"
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/lexical_cast.hpp>

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char *PLUGIN_MANIFEST =
    R"XML(<?xml version="1.0"?>                        
<OxygenPlugin name="SERIAL_CSV_PLUGIN" version="1.2" uuid="674c23a5-590a-4c7f-8aac-a97ed94a0ea5">
  <Info name="Serial Plugin: Simple ASCII Interpreter to Oxygen-Channels.">
    <Vendor name="DEWETRON GmbH"/>
    <Description>
    A simple plugin to further process data from a microcontroller send over serial. 
    Implements a simple, ASCII/CSV based protocol.
    </Description>
  </Info>
  <Host minimum_version="5.3"/>
  <UsesUIExtensions/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char *TRANSLATION_EN =
R"XML(<?xml version="1.0"?>

<!-- English -->
<TS version="2.1" language="en" sourcelanguage="en">

    <!-- Translations for Config-Keys -->
    <context><name>ConfigKeys</name>
        <message><source>SERIAL_CSV_PLUGIN/ComPort</source><translation>COM Port</translation></message>
        <message><source>SERIAL_CSV_PLUGIN/BaudRate</source><translation>Baud rate</translation></message>
    </context>



    <!-- Translations for custom UI item -->
    <context><name>SERIAL_CSV_PLUGIN/AddSerialCsvPort</name>
        <message><source>Not a valid CSV file</source><translation>No valid CSV file selected</translation></message>
    </context>
</TS>
)XML";


static const char* SERIAL_COM_PORT = "SERIAL_CSV_PLUGIN/ComPort";
static const char* SERIAL_BAUDRATE = "SERIAL_CSV_PLUGIN/BaudRate";

// Keys for ConfigItems that are used to store channel settings
// Custom key (prefixed by plugin name) to store path to the input file
// Value of common Oxygen key "SampleRate" determines the sample frequency and the playback rate for the channel

using namespace odk::framework;

class SerialCsvChannel : public SoftwareChannelInstance
{
public:
    SerialCsvChannel()
        : m_com_port_prop(new EditableStringProperty("COM-Port"))
        , m_baudrate_prop(new EditableStringProperty("Baudrate"))
        , m_num_channels()
        , m_channel_prop_vec()
        , m_csv_decoder()
    {
    }

    ~SerialCsvChannel()
    {
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Serial Plugin: Simply add serial data to oxygen.";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Data Sources";
        telegram.m_description = "Adds a serial port with a variable amount of channels to Oxygen. Default interpreter: CSV-Like format.";
        
        // Testing qml
        telegram.m_ui_item_add = "qml/AddSerialCsvPort";
        return telegram;
    }

    bool setup(const std::vector<odk::Property>& properties) override
    {
        odk::PropertyList props(properties);

        auto serialport = props.getString("SERIAL_CSV_PLUGIN/SerialPort");
        auto baudrate = props.getString("SERIAL_CSV_PLUGIN/BaudRate");
        auto numchannels = props.getString("SERIAL_CSV_PLUGIN/NumChannels");

        try
        {
            m_num_channels = boost::lexical_cast<uint32_t>(numchannels);
            m_baudrate_prop->setValue(baudrate);

        }
        catch(const boost::bad_lexical_cast&)
        { }

        if (m_num_channels > 0)
        {
            m_channel_prop_vec.resize(m_num_channels);

            {
                std::vector<std::string> name_vec;
                auto channel_names = props.getString("SERIAL_CSV_PLUGIN/ChannelNames");
                boost::split(name_vec, channel_names, boost::is_any_of(","));

                for (int i = 0; i < std::min(name_vec.size(), m_channel_prop_vec.size()); ++i)
                {
                    m_channel_prop_vec[i].name = name_vec[i];
                }
            }

            {
                std::vector<std::string> mins_vec;
                auto channel_mins = props.getString("SERIAL_CSV_PLUGIN/ChannelMins");
                boost::split(mins_vec, channel_mins, boost::is_any_of(","));

                for (int i = 0; i < std::min(mins_vec.size(), m_channel_prop_vec.size()); ++i)
                {
                    m_channel_prop_vec[i].mins = mins_vec[i];
                }
            }

            {
                std::vector<std::string> maxs_vec;
                auto channel_maxs = props.getString("SERIAL_CSV_PLUGIN/ChannelMaxs");
                boost::split(maxs_vec, channel_maxs, boost::is_any_of(","));

                for (int i = 0; i < std::min(maxs_vec.size(), m_channel_prop_vec.size()); ++i)
                {
                    m_channel_prop_vec[i].maxs = maxs_vec[i];
                }
            }

            {
                std::vector<std::string> units_vec;
                auto channel_units = props.getString("SERIAL_CSV_PLUGIN/ChannelUnits");
                boost::split(units_vec, channel_units, boost::is_any_of(","));

                for (int i = 0; i < std::min(units_vec.size(), m_channel_prop_vec.size()); ++i)
                {
                    m_channel_prop_vec[i].units = units_vec[i];
                }
            }

        }


        if (!serialport.empty() && !baudrate.empty())
        {
            m_com_port_prop->setValue(serialport);
            createChannels();
        }

        return true;
    }

    bool createChannels()
    {
        for (uint32_t channel_no = 0; channel_no < m_num_channels; ++channel_no)
        {
            std::string name;
            double min_v = -10;
            double max_v = +10;
            std::string unit = "V";

            try
            {
                const auto& ch_prop = m_channel_prop_vec.at(channel_no);
                name = ch_prop.name;

                if (name.empty())
                {
                    name = std::string("S ") + std::to_string(channel_no + 1);
                }

                min_v = std::stod(ch_prop.mins);
                max_v = std::stod(ch_prop.maxs);
                unit = ch_prop.units;
                unit.erase(0, 1);
                unit.erase(unit.size() - 1);

            }
            catch (const std::out_of_range&)
            {
            }
            catch (const std::invalid_argument&)
            {
            }

            auto channel = addOutputChannel(name);
            if (channel)
            {
                channel->setDefaultName(name)
                    .setSampleFormat(
                        odk::ChannelDataformat::SampleOccurrence::ASYNC,
                        odk::ChannelDataformat::SampleFormat::DOUBLE,
                        1)
                    .setRange({ min_v, max_v, unit, unit})
                    ;
            }
        }

        return true;
    }

    bool update() override
    {
        return true;
    }

    void updatePropertyTypes(const PluginChannelPtr &output_channel) override
    {
        ODK_UNUSED(output_channel);
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr &channel) override
    {
        ODK_UNUSED(channel);
    }

    void create(odk::IfHost* host) override
    {
        ODK_UNUSED(host);

        getRootChannel()->setDefaultName(std::string("Serial-CSV"))
            .setDeletable(true)
            .addProperty(SERIAL_COM_PORT, m_com_port_prop)
            .addProperty(SERIAL_BAUDRATE, m_baudrate_prop);
    }

    bool configure(
        const odk::UpdateChannelsTelegram &request,
        std::map<std::uint32_t, std::uint32_t> &channel_id_map) override
    {
        configureFromTelegram(request, channel_id_map);
        return true;
    }

    void prepareProcessing(odk::IfHost *host) override
    {
        ODK_UNUSED(host);
        uint32_t baudrate = 9600;
        try
        {
            baudrate = boost::lexical_cast<uint32_t>(m_baudrate_prop->getValue());
        }
        catch(const boost::bad_lexical_cast&) {}

        m_csv_decoder.setTimeSource([host](void) { return getMasterTimestamp(host).m_ticks; });

        serialcsv::SerialConfig serial_config{ m_com_port_prop->getValue(), baudrate };
        serial_config.flowcontrol = serial::flowcontrol_hardware;
        m_csv_decoder.listenOnComPort(serial_config);
    }

    void stopProcessing(odk::IfHost* host) override
    { 
        ODK_UNUSED(host);
        m_csv_decoder.stopListening();
        m_csv_decoder.clear();
        m_csv_decoder.setTimeSource({});
    }

    void process(ProcessingContext &context, odk::IfHost *host) override
    {
        ODK_UNUSED(context);
        ODK_UNUSED(host);

        // CSV source channels
        auto& csv_channels = m_csv_decoder.getChannels();

        // Oxygen channels
        const auto& channels = getOutputChannels();
        auto ts = getMasterTimestamp(host);

        int chidx = 0;
        for (auto ch : channels)
        {
            // skip parent group channel
            if (!ch->getLocalParent()) continue;

            // check out of range access
            if (chidx >= csv_channels.size()) return;

            auto& csv_chan = csv_channels.at(chidx);
               
            auto data_set = csv_chan->getAndResetDataset();

            for (const auto& sample : data_set)
            {
                addSample(host, ch->getLocalId(), sample.time, sample.value);
            }
            ++chidx;
        }
    }

private:
    std::shared_ptr<EditableStringProperty> m_com_port_prop;
    std::shared_ptr<EditableStringProperty> m_baudrate_prop;
    uint32_t m_num_channels;

    struct ChannelProp
    {
        std::string name;
        std::string mins;
        std::string maxs;
        std::string units;
    };
    std::vector<ChannelProp> m_channel_prop_vec;

    serialcsv::CsvDecoder m_csv_decoder;
};

class SerialCsvChannelPlugin : public SoftwareChannelPlugin<SerialCsvChannel>
{
public:
    SerialCsvChannelPlugin()
        : m_custom_requests(std::make_shared<odk::framework::CustomRequestHandler>())
        , m_csv_decoder()
    {
        addMessageHandler(m_custom_requests);

        namespace arg = std::placeholders;
        m_custom_requests->registerFunction(1, "queryComPorts", std::bind(&SerialCsvChannelPlugin::queryComPorts, this, arg::_1, arg::_2));
        m_custom_requests->registerFunction(2, "selectComPort", std::bind(&SerialCsvChannelPlugin::selectComPort, this, arg::_1, arg::_2));
    }

    void registerResources() final
    {
        addTranslation(TRANSLATION_EN);
        addQtResources(plugin_resources::QML_RCC_data, plugin_resources::QML_RCC_size);
    }

    std::uint64_t queryComPorts(const odk::PropertyList &params, odk::PropertyList &returns)
    {
        ODK_UNUSED(params);

        auto ser_port_list = serial::list_ports();

        // sort by name
        std::sort(ser_port_list.begin(), ser_port_list.end(), [](const serial::PortInfo& l, const serial::PortInfo& r) {
            return l.port < r.port;
            }
        );

        for (const auto& sp : ser_port_list)
        {
            returns.setString("", sp.port);
            returns.setString("", sp.description);
        }

        return odk::error_codes::OK;
    }

    std::uint64_t selectComPort(const odk::PropertyList& params, odk::PropertyList& returns)
    {
        ODK_UNUSED(params);

        const auto serialport = params.getString("serialport");
        const auto baudrate_string = params.getString("baudrate");

        uint64_t num_channels = 0;
        std::string channel_names;
        std::string channel_mins;
        std::string channel_maxs;
        std::string channel_units;

        m_csv_decoder.clear();

        if (!serialport.empty())
        {
            try
            {
                // configure serial port for channel scan

                uint32_t baudrate = boost::lexical_cast<uint32_t>(baudrate_string);
                serialcsv::SerialConfig serial_config{ serialport, baudrate };
                serial_config.flowcontrol = serial::flowcontrol_hardware;

                //serial::Timeout timeout(3, 3, 3, 0, 0);

                serial::Timeout timeout(3, 3, 3, 20, 3);
                serial::Serial test_port(serialport, baudrate);

                if (test_port.isOpen())
                {
                    test_port.close();

                    // signal port open
                    returns.setBool("status", true);

                    // start receive thread
                    m_csv_decoder.listenOnComPort(serial_config, timeout);

                    // request header (with retries)
                    m_csv_decoder.requestHeader(5);

                    // wait for some samples
                    std::this_thread::sleep_for(std::chrono::milliseconds(500));

                    const auto& channels = m_csv_decoder.getChannels();
                    num_channels = channels.size();
                    
                    for (int i=0; i<channels.size(); ++i)
                    {
                        const auto& ch = channels[i];

                        std::string key = std::string("CH") + std::to_string(i);

                        channel_names += ch->getName() + ",";
                        if (ch->hasMax())
                        {
                            channel_maxs += std::to_string(ch->getMax()) + ",";
                        }
                        else 
                        {
                            channel_maxs += ",";
                        }

                        if (ch->hasMin())
                        {
                            channel_mins += std::to_string(ch->getMin()) + ",";
                        }
                        else
                        {
                            channel_mins += ",";
                        }

                        if (ch->hasUnit()) 
                        {
                            channel_units += ch->getUnit() + ",";
                        }
                        else
                        {
                            channel_units += ",";
                        }

                    }
                    if (!channel_names.empty()) channel_names.pop_back();
                    if (!channel_maxs.empty()) channel_maxs.pop_back();
                    if (!channel_mins.empty()) channel_mins.pop_back();
                    if (!channel_units.empty()) channel_units.pop_back();

                    m_csv_decoder.stopListening();
                }
                else
                {
                    returns.setBool("status", false);
                }
            }
            catch(boost::bad_lexical_cast&)
            { 
                returns.setBool("status", false);
            }
            catch(const std::exception&)
            { 
                returns.setBool("status", false);
            }
        }

        returns.setDouble("NumChannels",  static_cast<double>(num_channels));
        returns.setString("ChannelNames", channel_names);
        returns.setString("ChannelMaxs",  channel_maxs);
        returns.setString("ChannelMins",  channel_mins);
        returns.setString("ChannelUnits", channel_units);

        return odk::error_codes::OK;
    }

private:
    std::shared_ptr<odk::framework::CustomRequestHandler> m_custom_requests;
    serialcsv::CsvDecoder m_csv_decoder;
};

OXY_REGISTER_PLUGIN1("SERIAL_CSV_PLUGIN", PLUGIN_MANIFEST, SerialCsvChannelPlugin);
